import hashlib
import socket
import ssl
from urllib.parse import urlparse

from OpenSSL import crypto

from maascommon.constants import SYSTEM_CA_FILE
from maasserver.models import Config
from provisioningserver.certificates import Certificate, CertificateRequest
from provisioningserver.utils.env import MAAS_UUID


def get_maas_client_cn(object_name: str | None):
    """Get a CN suitable for a client certificate.

    If the certificate is for a model object, like a Pod, the name of
    the object should be passed in, and the CN will look like
    '$maas_name@object_name'

    If the client certificate isn't tied to a specific object, None can
    be passed in, which will result in the CN beeing the MAAS name.
    """
    maas_name = Config.objects.get_config("maas_name")
    if object_name:
        # since the total length of the CN is 64, truncate the object name if
        # needed leaving the maas name intact
        object_name = object_name[: 63 - len(maas_name)]
    return f"{object_name}@{maas_name}" if object_name else maas_name


def generate_certificate(cn) -> Certificate:
    """Generate an X509 certificate with an RSA private key.

    Set O and OU so that we can identify that a certificate was
    created from this MAAS deployment.
    """
    # Set O and OU so that we can identify that a certificate was
    # created from this MAAS deployment.
    maas_uuid = MAAS_UUID.get()
    assert maas_uuid is not None, "MAAS_UUID not configured, ensure it is set."
    return Certificate.generate(
        cn,
        organization_name="MAAS",
        organizational_unit_name=maas_uuid,
    )


def generate_ca_certificate(cn: str) -> Certificate:
    """
    Generate an X509 MAAS CA certificate with an RSA private key.

    Set Organization (O) and Organizational Unit (OU) fields to identify
    that a certificate was created from this MAAS deployment.

    Parameters:
        cn (str): Common Name (CN) for the subject of the certificate.

    Returns:
        Certificate: The generated X509 MAAS CA certificate with an RSA private key.

    Raises:
        AssertionError: If the MAAS_UUID is not configured.
    """
    maas_uuid = MAAS_UUID.get()
    assert maas_uuid is not None, "MAAS_UUID not configured, ensure it is set."
    return Certificate.generate_ca_certificate(
        cn,
        organization_name="MAAS",
        organizational_unit_name=maas_uuid,
    )


def generate_signed_certificate(
    ca: Certificate, cn: str, subject_alternative_name: bytes | None = None
) -> Certificate:
    """
    Generate an X509 V3 certificate with an RSA private key signed with the root CA certificate provided.

    Parameters:
        ca (Certificate): The Certificate Authority (CA) certificate used to sign the generated certificate.
        cn (str): Common Name (CN) for the subject of the certificate.
        subject_alternative_name (bytes | None): Subject Alternative Name (SAN) for the certificate,
                                                  can be None if not needed.

    Returns:
        Certificate: The generated X509 V3 certificate signed with the root CA's private key.

    Raises:
        AssertionError: If the MAAS_UUID is not configured.
    """
    maas_uuid = MAAS_UUID.get()
    assert maas_uuid is not None, "MAAS_UUID not configured, ensure it is set."
    certificate_request = CertificateRequest.generate(
        cn,
        organization_name="MAAS",
        organizational_unit_name=maas_uuid,
        subject_alternative_name=subject_alternative_name,
    )
    return ca.sign_certificate_request(certificate_request)


def certificate_generated_by_this_maas(certificate: Certificate):
    """Return whether the certificate was generated by this MAAS deployment."""
    return certificate.o() == "MAAS" and certificate.ou() == MAAS_UUID.get()


def get_ssl_certificate(url, timeout=10):
    """Retrieve the SSL certificate and it's fingerprint for the given URL"""
    parsed_url = urlparse(url)
    if parsed_url.scheme != "https":
        return None, ""
    host = parsed_url.hostname
    port = 443
    if parsed_url.port:
        port = parsed_url.port
    conn = socket.create_connection((host, port))
    context = ssl.create_default_context()
    # in case the user has added a self signed certificate
    context.load_verify_locations(cafile=SYSTEM_CA_FILE)
    sock = context.wrap_socket(conn, server_hostname=host)
    sock.settimeout(timeout)
    try:
        der_cert = sock.getpeercert(True)
    finally:
        sock.close()
    pem_cert = ssl.DER_cert_to_PEM_cert(der_cert)
    return (
        crypto.load_certificate(crypto.FILETYPE_PEM, pem_cert),
        hashlib.sha1(der_cert).hexdigest(),
    )
